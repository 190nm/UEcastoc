package main

import (
	"encoding/binary"
	"fmt"
	"math/rand"
	"os"
	"strings"
)

type FSHAHash struct {
	Hash [20]byte
}

var (
	chunkIDExist map[FIoChunkID]bool
)

const (
	EIoChunkTypeBulkData         = 2
	EIoChunkTypeOptionalBulkData = 3
)

// hash would be generated by FSHA1
func (f *FSHAHash) ToString() string {
	return string(f.Hash[:]) // will probably not use this hash
}

// A string must have a preamble of the strlen and a nullbyte at the end.
// this function returns the string in the "FString" format.
func stringToFString(str string) []byte {
	strlen := uint32(len(str) + 1) // include nullbyte
	fstring := make([]byte, int(strlen)+binary.Size(strlen))
	binary.LittleEndian.PutUint32(fstring, strlen)
	for i := 0; i < len(str); i++ {
		fstring[4+i] = str[i]
	}
	fstring[len(fstring)-1] = 0
	return fstring
}

func getRandomBytes(n int) []byte {
	ret := make([]byte, n)
	rand.Read(ret)
	return ret
}

func createChunkID(filename string) *FIoChunkID {
	var id FIoChunkID
	if strings.Contains(filename, ".uasset") {
		id.Type = EIoChunkTypeBulkData
	} else if strings.Contains(filename, ".ubulk") {
		id.Type = EIoChunkTypeOptionalBulkData
	}
	id.Index = 0
	id.Padding = 0 // of course

	id.ID = rand.Uint64()
	return &id
}

func writeUint32ToFile(a *uint32, f *os.File) {
	t := make([]byte, 4)
	binary.LittleEndian.PutUint32(t, *a)
	f.Write(t)
}

func writeStructToFile(v any, f *os.File) {
	err := binary.Write(f, binary.LittleEndian, v)
	if err != nil {
		fmt.Println("err:", err)
		panic(err)
	}
}
