package uecastoc

import (
	"crypto/sha1"
	"encoding/binary"
	"encoding/json"
	"errors"
	"math/rand"
	"os"
)

type FSHAHash struct {
	Hash [20]byte
}

const (
	EIoChunkTypeBulkData         = 2
	EIoChunkTypeOptionalBulkData = 3
)

var ParsedDataPath string = "./Runtime/"

// hash would be generated by FSHA1
func (f *FSHAHash) ToString() string {
	return string(f.Hash[:]) // will probably not use this hash
}

// A string must have a preamble of the strlen and a nullbyte at the end.
// this function returns the string in the "FString" format.
func stringToFString(str string) []byte {
	strlen := uint32(len(str) + 1) // include nullbyte
	fstring := make([]byte, int(strlen)+binary.Size(strlen))
	binary.LittleEndian.PutUint32(fstring, strlen)
	for i := 0; i < len(str); i++ {
		fstring[4+i] = str[i]
	}
	fstring[len(fstring)-1] = 0
	return fstring
}

func getRandomBytes(n int) []byte {
	ret := make([]byte, n)
	rand.Read(ret)
	return ret
}

func uint32ToBytes(a *uint32) *[]byte {
	t := make([]byte, 4)
	binary.LittleEndian.PutUint32(t, *a)
	return &t
}

func saveParsedData(data *UTocData) error {
	os.MkdirAll(ParsedDataPath, 0700)
	dependencies, err := json.Marshal(data.Deps)
	if err != nil {
		return err
	}
	err = os.WriteFile(ParsedDataPath+"deps.json", dependencies, 0644)
	if err != nil {
		return err
	}
	fileIDs, err := json.Marshal(data.FNameToID)
	if err != nil {
		return err
	}
	err = os.WriteFile(ParsedDataPath+"fileIDs.json", fileIDs, 0644)

	return err
}

func loadParsedData() (*UTocData, error) {
	data := UTocData{}
	data.FNameToID = make(map[string]uint64)

	// check if files exist
	if _, err := os.Stat(ParsedDataPath + "deps.json"); errors.Is(err, os.ErrNotExist) {
		return nil, err
	}
	if _, err := os.Stat(ParsedDataPath + "fileIDs.json"); errors.Is(err, os.ErrNotExist) {
		return nil, err
	}

	deps, err := os.ReadFile(ParsedDataPath + "deps.json")
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(deps, &data.Deps)
	if err != nil {
		return nil, err
	}

	fileIDs, err := os.ReadFile(ParsedDataPath + "fileIDs.json")
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(fileIDs, &data.FNameToID)

	return &data, err
}
func sha1Hash(fdata *[]byte) *FIoChunkHash {
	hasher := sha1.New()
	hasher.Write(*fdata)
	fileHash := hasher.Sum(nil)

	var hash FIoChunkHash
	copy(hash.Hash[:], fileHash[:20])
	hash.Padding = [12]byte{} // explicitly set to 0
	return &hash
}
